-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [avl_verification]
import Base
open Primitives

namespace avl_verification

/- [avl_verification::Ordering]
   Source: 'src/main.rs', lines 21:0-21:17 -/
inductive Ordering :=
| Less : Ordering
| Equal : Ordering
| Greater : Ordering

/- Trait declaration: [avl_verification::Ord]
   Source: 'src/main.rs', lines 27:0-27:9 -/
structure Ord (Self : Type) where
  cmp : Self → Self → Result Ordering

/- [avl_verification::max]:
   Source: 'src/main.rs', lines 1:0-1:47 -/
def max (T : Type) (OrdInst : Ord T) (a : T) (b : T) : Result T :=
  do
  let o ← OrdInst.cmp a b
  match o with
  | Ordering.Less => Result.ok b
  | Ordering.Equal => Result.ok b
  | Ordering.Greater => Result.ok a

/- [avl_verification::{(avl_verification::Ord for usize)}::cmp]:
   Source: 'src/main.rs', lines 10:4-10:43 -/
def OrdUsize.cmp (self : Usize) (other : Usize) : Result Ordering :=
  if self < other
  then Result.ok Ordering.Less
  else
    if self = other
    then Result.ok Ordering.Equal
    else Result.ok Ordering.Greater

/- Trait implementation: [avl_verification::{(avl_verification::Ord for usize)}]
   Source: 'src/main.rs', lines 9:0-9:18 -/
def OrdUsize : Ord Usize := {
  cmp := OrdUsize.cmp
}

/- [avl_verification::AVLNode]
   Source: 'src/main.rs', lines 33:0-33:17 -/
inductive AVLNode (T : Type) :=
| mk : T → Option (AVLNode T) → Option (AVLNode T) → Usize → AVLNode T

/- [core::option::{core::option::Option<T>}::as_ref]:
   Source: '/rustc/d59363ad0b6391b7fc5bbb02c9ccf9300eef3753/library/core/src/option.rs', lines 673:4-673:44
   Name pattern: core::option::{core::option::Option<@T>}::as_ref -/
axiom core.option.Option.as_ref (T : Type) : Option T → Result (Option T)

/- Trait declaration: [core::ops::arith::Add]
   Source: '/rustc/d59363ad0b6391b7fc5bbb02c9ccf9300eef3753/library/core/src/ops/arith.rs', lines 76:0-76:25
   Name pattern: core::ops::arith::Add -/
structure core.ops.arith.Add (Self Rhs : Type) where
  Output : Type
  add : Self → Rhs → Result Output

/- [core::ops::arith::{(core::ops::arith::Add<usize> for usize)}::add]:
   Source: '/rustc/d59363ad0b6391b7fc5bbb02c9ccf9300eef3753/library/core/src/ops/arith.rs', lines 102:12-102:41
   Name pattern: core::ops::arith::{core::ops::arith::Add<usize, usize>}::add -/
axiom core.ops.arith.AddUsizeUsize.add : Usize → Usize → Result Usize

/- Trait implementation: [core::ops::arith::{(core::ops::arith::Add<usize> for usize)}]
   Source: '/rustc/d59363ad0b6391b7fc5bbb02c9ccf9300eef3753/library/core/src/ops/arith.rs', lines 97:8-103:9
   Name pattern: core::ops::arith::Add<usize, usize> -/
def core.ops.arith.AddUsizeUsize : core.ops.arith.Add Usize Usize := {
  Output := Usize
  add := core.ops.arith.AddUsizeUsize.add
}

/- [core::ops::arith::{(core::ops::arith::Add<&0 (usize)> for usize)#15}::add]:
   Source: '/rustc/d59363ad0b6391b7fc5bbb02c9ccf9300eef3753/library/core/src/internal_macros.rs', lines 44:12-44:68
   Name pattern: core::ops::arith::{core::ops::arith::Add<usize, &'0 usize>}::add -/
axiom core.ops.arith.AddUsize&0 Usize.add : Usize → Usize → Result Usize

/- Trait implementation: [core::ops::arith::{(core::ops::arith::Add<&0 (usize)> for usize)#15}]
   Source: '/rustc/d59363ad0b6391b7fc5bbb02c9ccf9300eef3753/library/core/src/internal_macros.rs', lines 40:8-47:9
   Name pattern: core::ops::arith::Add<usize, &'_ usize> -/
def core.ops.arith.AddUsize&0 Usize : core.ops.arith.Add Usize Usize := {
  Output := core.ops.arith.AddUsizeUsize.Output
  add := core.ops.arith.AddUsize&0 Usize.add
}

/- [avl_verification::{avl_verification::AVLNode<T>#1}::left_height]:
   Source: 'src/main.rs', lines 51:4-51:34 -/
def AVLNode.left_height (T : Type) (self : AVLNode T) : Result Usize :=
  sorry

/- [avl_verification::{avl_verification::AVLNode<T>#1}::right_height]:
   Source: 'src/main.rs', lines 59:4-59:35 -/
def AVLNode.right_height (T : Type) (self : AVLNode T) : Result Usize :=
  sorry

/- [avl_verification::{avl_verification::AVLNode<T>#1}::height]:
   Source: 'src/main.rs', lines 47:4-47:29 -/
def AVLNode.height (T : Type) (self : AVLNode T) : Result Usize :=
  sorry

/- [avl_verification::{avl_verification::AVLNode<T>#1}::update_height]:
   Source: 'src/main.rs', lines 43:4-43:31 -/
def AVLNode.update_height (T : Type) (self : AVLNode T) : Result (AVLNode T) :=
  sorry

/- [avl_verification::{avl_verification::AVLNode<T>#1}::balance_factor]:
   Source: 'src/main.rs', lines 67:4-67:34 -/
def AVLNode.balance_factor (T : Type) (self : AVLNode T) : Result I8 :=
  do
  let left_height ← AVLNode.left_height T self
  let right_height ← AVLNode.right_height T self
  if left_height >= right_height
  then do
       let i ← left_height - right_height
       Scalar.cast .I8 i
  else
    do
    let i ← right_height - left_height
    let i1 ← Scalar.cast .I8 i
    -. i1

/- [core::option::{core::option::Option<T>}::is_none]:
   Source: '/rustc/d59363ad0b6391b7fc5bbb02c9ccf9300eef3753/library/core/src/option.rs', lines 642:4-642:39
   Name pattern: core::option::{core::option::Option<@T>}::is_none -/
axiom core.option.Option.is_none (T : Type) : Option T → Result Bool

/- [core::option::{core::option::Option<T>}::as_mut]:
   Source: '/rustc/d59363ad0b6391b7fc5bbb02c9ccf9300eef3753/library/core/src/option.rs', lines 695:4-695:52
   Name pattern: core::option::{core::option::Option<@T>}::as_mut -/
axiom core.option.Option.as_mut
  (T : Type) :
  Option T → Result ((Option T) × (Option T → Result (Option T)))

/- [core::option::{core::option::Option<T>}::unwrap]:
   Source: '/rustc/d59363ad0b6391b7fc5bbb02c9ccf9300eef3753/library/core/src/option.rs', lines 932:4-932:34
   Name pattern: core::option::{core::option::Option<@T>}::unwrap -/
axiom core.option.Option.unwrap (T : Type) : Option T → Result T

/- [core::option::{core::option::Option<T>}::take]:
   Source: '/rustc/d59363ad0b6391b7fc5bbb02c9ccf9300eef3753/library/core/src/option.rs', lines 1675:4-1675:45
   Name pattern: core::option::{core::option::Option<@T>}::take -/
axiom core.option.Option.take
  (T : Type) : Option T → Result ((Option T) × (Option T))

/- [core::mem::swap]:
   Source: '/rustc/d59363ad0b6391b7fc5bbb02c9ccf9300eef3753/library/core/src/mem/mod.rs', lines 726:0-726:42
   Name pattern: core::mem::swap -/
axiom core.mem.swap (T : Type) : T → T → Result (T × T)

/- [avl_verification::{avl_verification::AVLNode<T>#1}::rotate_right]:
   Source: 'src/main.rs', lines 78:4-78:38 -/
def AVLNode.rotate_right
  (T : Type) (self : AVLNode T) : Result (Bool × (AVLNode T)) :=
  sorry

/- [avl_verification::{avl_verification::AVLNode<T>#1}::rotate_left]:
   Source: 'src/main.rs', lines 106:4-106:37 -/
def AVLNode.rotate_left
  (T : Type) (self : AVLNode T) : Result (Bool × (AVLNode T)) :=
  sorry

/- [avl_verification::{avl_verification::AVLNode<T>#1}::rebalance]:
   Source: 'src/main.rs', lines 134:4-134:35 -/
def AVLNode.rebalance
  (T : Type) (self : AVLNode T) : Result (Bool × (AVLNode T)) :=
  sorry

/- [avl_verification::AVLTreeSet]
   Source: 'src/main.rs', lines 165:0-165:20 -/
structure AVLTreeSet (T : Type) where
  root : Option (AVLNode T)

/- [avl_verification::{avl_verification::AVLTreeSet<T>#2}::new]:
   Source: 'src/main.rs', lines 170:4-170:24 -/
def AVLTreeSet.new (T : Type) (OrdInst : Ord T) : Result (AVLTreeSet T) :=
  Result.ok { root := none }

/- [avl_verification::{avl_verification::AVLTreeSet<T>#2}::search]:
   Source: 'src/main.rs', lines 174:4-174:46 -/
def AVLTreeSet.search
  (T : Type) (OrdInst : Ord T) (self : AVLTreeSet T) (value : T) :
  Result (Bool × (AVLTreeSet T))
  :=
  sorry

/- [avl_verification::{avl_verification::AVLTreeSet<T>#2}::insert_phase1]: loop 0:
   Source: 'src/main.rs', lines 188:4-208:5 -/
divergent def AVLTreeSet.insert_phase1_loop
  (T : Type) (OrdInst : Ord T) (value : T) (current_tree : Option (AVLNode T))
  :
  Result (Bool × (Option (AVLNode T)))
  :=
  match current_tree with
  | none =>
    let a := AVLNode.mk value none none 0#usize
    Result.ok (true, some a)
  | some current_node =>
    do
    let ⟨ t, current_tree1, current_tree2, i ⟩ := current_node
    let ordering ← OrdInst.cmp t value
    match ordering with
    | Ordering.Less =>
      do
      let (b, current_tree3) ←
        AVLTreeSet.insert_phase1_loop T OrdInst value current_tree2
      Result.ok (b, some (AVLNode.mk t current_tree1 current_tree3 i))
    | Ordering.Equal =>
      Result.ok (false, some (AVLNode.mk t current_tree1 current_tree2 i))
    | Ordering.Greater =>
      do
      let (b, current_tree3) ←
        AVLTreeSet.insert_phase1_loop T OrdInst value current_tree1
      Result.ok (b, some (AVLNode.mk t current_tree3 current_tree2 i))

/- [avl_verification::{avl_verification::AVLTreeSet<T>#2}::insert_phase1]:
   Source: 'src/main.rs', lines 188:4-188:49 -/
def AVLTreeSet.insert_phase1
  (T : Type) (OrdInst : Ord T) (self : AVLTreeSet T) (value : T) :
  Result (Bool × (AVLTreeSet T))
  :=
  do
  let (b, as) ← AVLTreeSet.insert_phase1_loop T OrdInst value self.root
  Result.ok (b, { root := as })

/- [avl_verification::{avl_verification::AVLTreeSet<T>#2}::insert_rebalance_left]: loop 0:
   Source: 'src/main.rs', lines 210:4-218:5 -/
divergent def AVLTreeSet.insert_rebalance_left_loop
  (T : Type) (OrdInst : Ord T) (current_tree : Option (AVLNode T)) :
  Result (Option (AVLNode T))
  :=
  match current_tree with
  | none => Result.ok none
  | some current_node =>
    do
    let current_node1 ← AVLNode.update_height T current_node
    let (_, current_node2) ← AVLNode.rebalance T current_node1
    let ⟨ t, current_tree1, o, i ⟩ := current_node2
    let current_tree2 ←
      AVLTreeSet.insert_rebalance_left_loop T OrdInst current_tree1
    Result.ok (some (AVLNode.mk t current_tree2 o i))

/- [avl_verification::{avl_verification::AVLTreeSet<T>#2}::insert_rebalance_left]:
   Source: 'src/main.rs', lines 210:4-210:39 -/
def AVLTreeSet.insert_rebalance_left
  (T : Type) (OrdInst : Ord T) (self : AVLTreeSet T) : Result (AVLTreeSet T) :=
  do
  let as ← AVLTreeSet.insert_rebalance_left_loop T OrdInst self.root
  Result.ok { root := as }

/- [avl_verification::{avl_verification::AVLTreeSet<T>#2}::insert_rebalance_right]: loop 0:
   Source: 'src/main.rs', lines 220:4-228:5 -/
divergent def AVLTreeSet.insert_rebalance_right_loop
  (T : Type) (OrdInst : Ord T) (current_tree : Option (AVLNode T)) :
  Result (Option (AVLNode T))
  :=
  match current_tree with
  | none => Result.ok none
  | some current_node =>
    do
    let current_node1 ← AVLNode.update_height T current_node
    let (_, current_node2) ← AVLNode.rebalance T current_node1
    let ⟨ t, o, current_tree1, i ⟩ := current_node2
    let current_tree2 ←
      AVLTreeSet.insert_rebalance_right_loop T OrdInst current_tree1
    Result.ok (some (AVLNode.mk t o current_tree2 i))

/- [avl_verification::{avl_verification::AVLTreeSet<T>#2}::insert_rebalance_right]:
   Source: 'src/main.rs', lines 220:4-220:40 -/
def AVLTreeSet.insert_rebalance_right
  (T : Type) (OrdInst : Ord T) (self : AVLTreeSet T) : Result (AVLTreeSet T) :=
  do
  let as ← AVLTreeSet.insert_rebalance_right_loop T OrdInst self.root
  Result.ok { root := as }

/- [avl_verification::{avl_verification::AVLTreeSet<T>#2}::insert]:
   Source: 'src/main.rs', lines 230:4-230:46 -/
def AVLTreeSet.insert
  (T : Type) (OrdInst : Ord T) (self : AVLTreeSet T) (value : T) :
  Result (Bool × (AVLTreeSet T))
  :=
  do
  let (b, self1) ← AVLTreeSet.insert_phase1 T OrdInst self value
  if ¬ b
  then Result.ok (false, self1)
  else
    do
    let self2 ← AVLTreeSet.insert_rebalance_left T OrdInst self1
    let self3 ← AVLTreeSet.insert_rebalance_right T OrdInst self2
    Result.ok (true, self3)

/- [avl_verification::main]:
   Source: 'src/main.rs', lines 242:0-242:9 -/
def main : Result Unit :=
  Result.ok ()

end avl_verification
