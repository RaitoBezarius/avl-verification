-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [avl_verification]
import Base
open Primitives

namespace avl_verification

/- [avl_verification::Ordering]
   Source: 'src/main.rs', lines 21:0-21:17 -/
inductive Ordering :=
| Less : Ordering
| Equal : Ordering
| Greater : Ordering

/- Trait declaration: [avl_verification::Ord]
   Source: 'src/main.rs', lines 27:0-27:9 -/
structure Ord (Self : Type) where
  cmp : Self → Self → Result Ordering

/- Trait declaration: [core::marker::Copy]
   Source: '/rustc/d59363ad0b6391b7fc5bbb02c9ccf9300eef3753/library/core/src/marker.rs', lines 450:0-450:21
   Name pattern: core::marker::Copy -/
structure core.marker.Copy (Self : Type) where
  cloneCloneInst : core.clone.Clone Self

/- [avl_verification::max]:
   Source: 'src/main.rs', lines 1:0-1:38 -/
def max
  (T : Type) (OrdInst : Ord T) (coremarkerCopyInst : core.marker.Copy T)
  (a : T) (b : T) :
  Result T
  :=
  do
  let o ← OrdInst.cmp a b
  match o with
  | Ordering.Less => Result.ok b
  | Ordering.Equal => Result.ok b
  | Ordering.Greater => Result.ok a

/- [avl_verification::{(avl_verification::Ord for usize)}::cmp]:
   Source: 'src/main.rs', lines 10:4-10:43 -/
def OrdUsize.cmp (self : Usize) (other : Usize) : Result Ordering :=
  if self < other
  then Result.ok Ordering.Less
  else
    if self = other
    then Result.ok Ordering.Equal
    else Result.ok Ordering.Greater

/- Trait implementation: [avl_verification::{(avl_verification::Ord for usize)}]
   Source: 'src/main.rs', lines 9:0-9:18 -/
def OrdUsize : Ord Usize := {
  cmp := OrdUsize.cmp
}

/- [avl_verification::AVLNode]
   Source: 'src/main.rs', lines 33:0-33:17 -/
inductive AVLNode (T : Type) :=
| mk : T → Option (AVLNode T) → Option (AVLNode T) → Usize → AVLNode T

/- Trait implementation: [core::marker::{(core::marker::Copy for usize)#37}]
   Source: '/rustc/d59363ad0b6391b7fc5bbb02c9ccf9300eef3753/library/core/src/marker.rs', lines 47:29-47:65
   Name pattern: core::marker::Copy<usize> -/
def core.marker.CopyUsize : core.marker.Copy Usize := {
  cloneCloneInst := core.clone.CloneUsize
}

/- [avl_verification::{avl_verification::AVLNode<T>#1}::left_height]:
   Source: 'src/main.rs', lines 51:4-51:34 -/
mutual divergent def AVLNode.left_height
  (T : Type) (self : AVLNode T) : Result Usize :=
  let ⟨ _, o, _, _ ⟩ := self
  match o with
  | none => Result.ok 0#usize
  | some left => AVLNode.height T left

/- [avl_verification::{avl_verification::AVLNode<T>#1}::right_height]:
   Source: 'src/main.rs', lines 59:4-59:35 -/
divergent def AVLNode.right_height
  (T : Type) (self : AVLNode T) : Result Usize :=
  let ⟨ _, _, o, _ ⟩ := self
  match o with
  | none => Result.ok 0#usize
  | some right => AVLNode.height T right

/- [avl_verification::{avl_verification::AVLNode<T>#1}::height]:
   Source: 'src/main.rs', lines 47:4-47:29 -/
divergent def AVLNode.height (T : Type) (self : AVLNode T) : Result Usize :=
  do
  let i ← AVLNode.left_height T self
  let i1 ← AVLNode.right_height T self
  let i2 ← max Usize OrdUsize core.marker.CopyUsize i i1
  1#usize + i2

end

/- [avl_verification::{avl_verification::AVLNode<T>#1}::update_height]:
   Source: 'src/main.rs', lines 43:4-43:31 -/
def AVLNode.update_height (T : Type) (self : AVLNode T) : Result (AVLNode T) :=
  do
  let i ← AVLNode.left_height T self
  let i1 ← AVLNode.right_height T self
  let i2 ← max Usize OrdUsize core.marker.CopyUsize i i1
  let i3 ← 1#usize + i2
  let ⟨ t, o, o1, _ ⟩ := self
  Result.ok (AVLNode.mk t o o1 i3)

/- [avl_verification::{avl_verification::AVLNode<T>#1}::balance_factor]:
   Source: 'src/main.rs', lines 67:4-67:34 -/
def AVLNode.balance_factor (T : Type) (self : AVLNode T) : Result I8 :=
  do
  let left_height ← AVLNode.left_height T self
  let right_height ← AVLNode.right_height T self
  if left_height >= right_height
  then do
       let i ← left_height - right_height
       Scalar.cast .I8 i
  else
    do
    let i ← right_height - left_height
    let i1 ← Scalar.cast .I8 i
    -. i1

/- [core::option::{core::option::Option<T>}::is_none]:
   Source: '/rustc/d59363ad0b6391b7fc5bbb02c9ccf9300eef3753/library/core/src/option.rs', lines 642:4-642:39
   Name pattern: core::option::{core::option::Option<@T>}::is_none -/
axiom core.option.Option.is_none (T : Type) : Option T → Result Bool

/- [core::option::{core::option::Option<T>}::take]:
   Source: '/rustc/d59363ad0b6391b7fc5bbb02c9ccf9300eef3753/library/core/src/option.rs', lines 1675:4-1675:45
   Name pattern: core::option::{core::option::Option<@T>}::take -/
axiom core.option.Option.take
  (T : Type) : Option T → Result ((Option T) × (Option T))

/- [core::mem::swap]:
   Source: '/rustc/d59363ad0b6391b7fc5bbb02c9ccf9300eef3753/library/core/src/mem/mod.rs', lines 726:0-726:42
   Name pattern: core::mem::swap -/
axiom core.mem.swap (T : Type) : T → T → Result (T × T)

/- [avl_verification::{avl_verification::AVLNode<T>#1}::rotate_right]:
   Source: 'src/main.rs', lines 78:4-78:38 -/
def AVLNode.rotate_right
  (T : Type) (self : AVLNode T) : Result (Bool × (AVLNode T)) :=
  do
  let ⟨ t, o, o1, i ⟩ := self
  let b ← core.option.Option.is_none (AVLNode T) o
  if b
  then Result.ok (false, AVLNode.mk t o o1 i)
  else
    match o with
    | none => Result.fail .panic
    | some left_node =>
      do
      let ⟨ t1, o2, o3, i1 ⟩ := left_node
      let (left_right_tree, o4) ← core.option.Option.take (AVLNode T) o3
      let (left_left_tree, o5) ← core.option.Option.take (AVLNode T) o2
      let (new_right_tree, o6) :=
        core.mem.replace (Option (AVLNode T)) (some (AVLNode.mk t1 o5 o4 i1))
          left_left_tree
      match new_right_tree with
      | none => Result.fail .panic
      | some new_right_tree1 =>
        do
        let ⟨ t2, _, _, i2 ⟩ := new_right_tree1
        let (t3, t4) ← core.mem.swap T t t2
        let (right_tree, _) ← core.option.Option.take (AVLNode T) o1
        let node ←
          AVLNode.update_height T (AVLNode.mk t4 left_right_tree right_tree i2)
        let self1 ← AVLNode.update_height T (AVLNode.mk t3 o6 (some node) i)
        Result.ok (true, self1)

/- [avl_verification::{avl_verification::AVLNode<T>#1}::rotate_left]:
   Source: 'src/main.rs', lines 117:4-117:37 -/
def AVLNode.rotate_left
  (T : Type) (self : AVLNode T) : Result (Bool × (AVLNode T)) :=
  do
  let ⟨ t, o, o1, i ⟩ := self
  let b ← core.option.Option.is_none (AVLNode T) o1
  if b
  then Result.ok (false, AVLNode.mk t o o1 i)
  else
    match o1 with
    | none => Result.fail .panic
    | some right_node =>
      do
      let ⟨ t1, o2, o3, i1 ⟩ := right_node
      let (right_left_tree, o4) ← core.option.Option.take (AVLNode T) o2
      let (right_right_tree, o5) ← core.option.Option.take (AVLNode T) o3
      let (new_left_tree, o6) :=
        core.mem.replace (Option (AVLNode T)) (some (AVLNode.mk t1 o4 o5 i1))
          right_right_tree
      match new_left_tree with
      | none => Result.fail .panic
      | some new_left_tree1 =>
        do
        let ⟨ t2, _, _, i2 ⟩ := new_left_tree1
        let (t3, t4) ← core.mem.swap T t t2
        let (left_tree, _) ← core.option.Option.take (AVLNode T) o
        let node ←
          AVLNode.update_height T (AVLNode.mk t4 left_tree right_left_tree i2)
        let self1 ← AVLNode.update_height T (AVLNode.mk t3 (some node) o6 i)
        Result.ok (true, self1)

/- [avl_verification::{avl_verification::AVLNode<T>#1}::rebalance]:
   Source: 'src/main.rs', lines 155:4-155:35 -/
def AVLNode.rebalance
  (T : Type) (self : AVLNode T) : Result (Bool × (AVLNode T)) :=
  do
  let i ← AVLNode.balance_factor T self
  match i with
  | (-2)#i8 =>
    let ⟨ t, o, o1, i1 ⟩ := self
    match o1 with
    | none => Result.fail .panic
    | some right_node =>
      do
      let i2 ← AVLNode.balance_factor T right_node
      if i2 = 1#i8
      then
        do
        let (_, right_node1) ← AVLNode.rotate_right T right_node
        let (_, self1) ←
          AVLNode.rotate_left T (AVLNode.mk t o (some right_node1) i1)
        Result.ok (true, self1)
      else
        do
        let (_, self1) ←
          AVLNode.rotate_left T (AVLNode.mk t o (some right_node) i1)
        Result.ok (true, self1)
  | 2#i8 =>
    let ⟨ t, o, o1, i1 ⟩ := self
    match o with
    | none => Result.fail .panic
    | some left_node =>
      do
      let i2 ← AVLNode.balance_factor T left_node
      if i2 = 1#i8
      then
        do
        let (_, left_node1) ← AVLNode.rotate_left T left_node
        let (_, self1) ←
          AVLNode.rotate_right T (AVLNode.mk t (some left_node1) o1 i1)
        Result.ok (true, self1)
      else
        do
        let (_, self1) ←
          AVLNode.rotate_right T (AVLNode.mk t (some left_node) o1 i1)
        Result.ok (true, self1)
  | _ => Result.ok (false, self)

/- [avl_verification::AVLTreeSet]
   Source: 'src/main.rs', lines 190:0-190:20 -/
structure AVLTreeSet (T : Type) where
  root : Option (AVLNode T)

/- [avl_verification::{avl_verification::AVLTreeSet<T>#2}::new]:
   Source: 'src/main.rs', lines 195:4-195:24 -/
def AVLTreeSet.new (T : Type) (OrdInst : Ord T) : Result (AVLTreeSet T) :=
  Result.ok { root := none }

/- [avl_verification::{avl_verification::AVLTreeSet<T>#2}::insert_phase1]: loop 0:
   Source: 'src/main.rs', lines 199:4-219:5 -/
divergent def AVLTreeSet.insert_phase1_loop
  (T : Type) (OrdInst : Ord T) (value : T) (current_tree : Option (AVLNode T))
  :
  Result (Bool × (Option (AVLNode T)))
  :=
  match current_tree with
  | none =>
    let a := AVLNode.mk value none none 0#usize
    Result.ok (true, some a)
  | some current_node =>
    do
    let ⟨ t, current_tree1, current_tree2, i ⟩ := current_node
    let ordering ← OrdInst.cmp t value
    match ordering with
    | Ordering.Less =>
      do
      let (b, current_tree3) ←
        AVLTreeSet.insert_phase1_loop T OrdInst value current_tree2
      Result.ok (b, some (AVLNode.mk t current_tree1 current_tree3 i))
    | Ordering.Equal =>
      Result.ok (false, some (AVLNode.mk t current_tree1 current_tree2 i))
    | Ordering.Greater =>
      do
      let (b, current_tree3) ←
        AVLTreeSet.insert_phase1_loop T OrdInst value current_tree1
      Result.ok (b, some (AVLNode.mk t current_tree3 current_tree2 i))

/- [avl_verification::{avl_verification::AVLTreeSet<T>#2}::insert_phase1]:
   Source: 'src/main.rs', lines 199:4-199:49 -/
def AVLTreeSet.insert_phase1
  (T : Type) (OrdInst : Ord T) (self : AVLTreeSet T) (value : T) :
  Result (Bool × (AVLTreeSet T))
  :=
  do
  let (b, as) ← AVLTreeSet.insert_phase1_loop T OrdInst value self.root
  Result.ok (b, { root := as })

/- [avl_verification::{avl_verification::AVLTreeSet<T>#2}::insert_rebalance_left]: loop 0:
   Source: 'src/main.rs', lines 221:4-229:5 -/
divergent def AVLTreeSet.insert_rebalance_left_loop
  (T : Type) (OrdInst : Ord T) (current_tree : Option (AVLNode T)) :
  Result (Option (AVLNode T))
  :=
  match current_tree with
  | none => Result.ok none
  | some current_node =>
    do
    let current_node1 ← AVLNode.update_height T current_node
    let (_, current_node2) ← AVLNode.rebalance T current_node1
    let ⟨ t, current_tree1, o, i ⟩ := current_node2
    let current_tree2 ←
      AVLTreeSet.insert_rebalance_left_loop T OrdInst current_tree1
    Result.ok (some (AVLNode.mk t current_tree2 o i))

/- [avl_verification::{avl_verification::AVLTreeSet<T>#2}::insert_rebalance_left]:
   Source: 'src/main.rs', lines 221:4-221:39 -/
def AVLTreeSet.insert_rebalance_left
  (T : Type) (OrdInst : Ord T) (self : AVLTreeSet T) : Result (AVLTreeSet T) :=
  do
  let as ← AVLTreeSet.insert_rebalance_left_loop T OrdInst self.root
  Result.ok { root := as }

/- [avl_verification::{avl_verification::AVLTreeSet<T>#2}::insert_rebalance_right]: loop 0:
   Source: 'src/main.rs', lines 231:4-239:5 -/
divergent def AVLTreeSet.insert_rebalance_right_loop
  (T : Type) (OrdInst : Ord T) (current_tree : Option (AVLNode T)) :
  Result (Option (AVLNode T))
  :=
  match current_tree with
  | none => Result.ok none
  | some current_node =>
    do
    let current_node1 ← AVLNode.update_height T current_node
    let (_, current_node2) ← AVLNode.rebalance T current_node1
    let ⟨ t, o, current_tree1, i ⟩ := current_node2
    let current_tree2 ←
      AVLTreeSet.insert_rebalance_right_loop T OrdInst current_tree1
    Result.ok (some (AVLNode.mk t o current_tree2 i))

/- [avl_verification::{avl_verification::AVLTreeSet<T>#2}::insert_rebalance_right]:
   Source: 'src/main.rs', lines 231:4-231:40 -/
def AVLTreeSet.insert_rebalance_right
  (T : Type) (OrdInst : Ord T) (self : AVLTreeSet T) : Result (AVLTreeSet T) :=
  do
  let as ← AVLTreeSet.insert_rebalance_right_loop T OrdInst self.root
  Result.ok { root := as }

/- [avl_verification::{avl_verification::AVLTreeSet<T>#2}::insert]:
   Source: 'src/main.rs', lines 241:4-241:46 -/
def AVLTreeSet.insert
  (T : Type) (OrdInst : Ord T) (self : AVLTreeSet T) (value : T) :
  Result (Bool × (AVLTreeSet T))
  :=
  do
  let (b, self1) ← AVLTreeSet.insert_phase1 T OrdInst self value
  if ¬ b
  then Result.ok (false, self1)
  else
    do
    let self2 ← AVLTreeSet.insert_rebalance_left T OrdInst self1
    let self3 ← AVLTreeSet.insert_rebalance_right T OrdInst self2
    Result.ok (true, self3)

/- [avl_verification::main]:
   Source: 'src/main.rs', lines 253:0-253:9 -/
def main : Result Unit :=
  Result.ok ()

end avl_verification
